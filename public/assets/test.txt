import React, { useState, useEffect } from "react";
import Game from "./GameCanvas";
import {
  BrowserProvider,
  Contract,
  parseEther,
  JsonRpcProvider,
} from "ethers"; 
import LeaderboardABI from "../abis/LeaderboardABI.json";
import { usePrivy, useWallets } from "@privy-io/react-auth";
import "../Dashboard.css";

const CONTRACT_ADDRESS = import.meta.env.VITE_CONTRACT_ADDRESS;
const RPC_URL = "https://testnet-rpc.monad.xyz"; // üî• fallback provider

const Dashboard = () => {
  const [activeTab, setActiveTab] = useState("dashboard");
  const [walletAddress, setWalletAddress] = useState(null);
  const [registered, setRegistered] = useState(false);
  const [leaderboard, setLeaderboard] = useState([]);
  const [highScore, setHighScore] = useState(0);
  const [loadingLeaderboard, setLoadingLeaderboard] = useState(false);
  const [leaderboardError, setLeaderboardError] = useState(null);

  const { login, logout, authenticated, user } = usePrivy();
  const { wallets } = useWallets(); 

  // ‚úÖ Fetch leaderboard (always visible)
  const fetchLeaderboard = async () => {
    setLoadingLeaderboard(true);
    setLeaderboardError(null);

    try {
      let provider;
      if (window.ethereum) {
        provider = new BrowserProvider(window.ethereum);
      } else {
        provider = new JsonRpcProvider(RPC_URL); // read-only
      }

      const contract = new Contract(CONTRACT_ADDRESS, LeaderboardABI, provider);

      const players = await contract.getPlayers();
      let scores = [];
      for (let i = 0; i < players.length; i++) {
        const playerData = await contract.getPlayer(players[i]);
        scores.push({
          address: players[i],
          score: Number(playerData[0]),
          registered: playerData[1],
        });
      }

      scores = scores.sort((a, b) => b.score - a.score).slice(0, 10);
      setLeaderboard(scores);

      console.log("‚úÖ Leaderboard fetched:", scores);
    } catch (err) {
      console.error("‚ùå Error fetching leaderboard:", err);
      setLeaderboardError("Failed to load leaderboard. Please try again.");
    } finally {
      setLoadingLeaderboard(false);
    }
  };

  useEffect(() => {
    fetchLeaderboard();
  }, []);

  // ‚úÖ Get signer
  const getSigner = async () => {
    if (!authenticated || !user) throw new Error("Not logged in with Game ID");

    const embeddedWallet = wallets.find(w => w.walletClientType === "privy");
    if (embeddedWallet) {
      const provider = new BrowserProvider(await embeddedWallet.getEthereumProvider());
      return await provider.getSigner();
    }

    if (window.ethereum) {
      const provider = new BrowserProvider(window.ethereum);
      return await provider.getSigner();
    }

    throw new Error("No wallet provider found");
  };

  // ‚úÖ Sync registration + high score
  useEffect(() => {
    const checkRegistration = async () => {
      if (authenticated) {
        const mainWallet = wallets[0] || user?.wallet;
        if (!mainWallet) return;

        setWalletAddress(mainWallet.address);

        try {
          const signer = await getSigner();
          const contract = new Contract(CONTRACT_ADDRESS, LeaderboardABI, signer);
          const player = await contract.getPlayer(mainWallet.address);
          setRegistered(player[1]);
          setHighScore(Number(player[0]));
        } catch (err) {
          console.error("Error checking registration:", err);
        }
      }
    };
    checkRegistration();
  }, [authenticated, user, wallets]);

  // Register
  const handleRegister = async () => {
    try {
      if (!walletAddress || registered) return;

      const signer = await getSigner();
      const contract = new Contract(CONTRACT_ADDRESS, LeaderboardABI, signer);

      const tx = await contract.register({ value: parseEther("0.1") });
      await tx.wait();

      alert("‚úÖ You are now registered!");
      setRegistered(true);
      fetchLeaderboard();
    } catch (err) {
      console.error("Registration failed:", err);
      alert("‚ùå Registration failed: " + (err.message || err));
    }
  };

  // ‚úÖ Add new score
  const addScore = async (score) => {
    if (!walletAddress) return;

    if (registered && score > highScore) {
      try {
        const signer = await getSigner();
        const contract = new Contract(CONTRACT_ADDRESS, LeaderboardABI, signer);

        const tx = await contract.updateScore(score);
        await tx.wait();

        console.log("‚úÖ New high score submitted:", score);
        setHighScore(score);
        fetchLeaderboard();
      } catch (err) {
        console.error("Error submitting score:", err);
      }
    } else {
      console.log("‚ÑπÔ∏è Score not saved on-chain (not registered or not higher).");
    }
  };

  const renderContent = () => {
    switch (activeTab) {
      case "dashboard":
        return (
          <div>
            {!registered && walletAddress ? (
              <p style={{ color: "red", textAlign: "center" }}>
                ‚ö†Ô∏è You must{" "}
                <span
                  style={{ textDecoration: "underline", cursor: "pointer" }}
                  onClick={handleRegister}
                >
                  register (0.1 MON)
                </span>{" "}
                to save scores.
              </p>
            ) : null}
            <Game onGameOver={addScore} />
          </div>
        );
      case "leaderboard":
        return (
          <div className="leaderboard">
            <h2>üèÜ On-Chain Leaderboard</h2>
            {loadingLeaderboard ? (
              <p>‚è≥ Loading leaderboard...</p>
            ) : leaderboardError ? (
              <p style={{ color: "red" }}>{leaderboardError}</p>
            ) : leaderboard.length > 0 ? (
              <ol>
                {leaderboard.map((player, index) => {
                  let medal = "";
                  if (index === 0) medal = " ü•á";
                  else if (index === 1) medal = " ü•à";
                  else if (index === 2) medal = " ü•â";

                  return (
                    <li key={player.address}>
                      {player.address.slice(0, 6)}...{player.address.slice(-4)} ‚Äî {player.score}
                      {medal}
                    </li>
                  );
                })}
              </ol>
            ) : (
              <p>No players yet.</p>
            )}
          </div>
        );
      case "profile":
        return (
          <div className="profile">
            <h2>üë§ Player Profile</h2>
            <div className="profile-card">
              <p><strong>Wallet:</strong> {walletAddress || "Not connected"}</p>
              <p><strong>Status:</strong> {registered ? "‚úÖ Registered" : "‚ùå Not Registered"}</p>
              <p><strong>Highest Score:</strong> {highScore}</p>
              <p><strong>Games Played:</strong> {leaderboard.length}</p>
            </div>
          </div>
        );
      default:
        return <Game onGameOver={addScore} />;
    }
  };

  return (
    <div className="dashboard">
      <nav className="nav-bar">
        <button onClick={() => setActiveTab("dashboard")}>Dashboard</button>
        <button onClick={() => setActiveTab("leaderboard")}>Leaderboard</button>
        <button onClick={() => setActiveTab("profile")}>Profile</button>
      </nav>

      <div className="wallet-connect">
        {!authenticated ? (
          <button onClick={login}>Login with Monad Games ID</button>
        ) : (
          <div>
            <p>üë§ Logged in with Game ID</p>
            <p>
              Wallet: {walletAddress ? walletAddress.slice(0, 6) + "..." + walletAddress.slice(-4) : "‚Äî"}
            </p>
            <p>
              Status:{" "}
              {registered ? (
                <span style={{ color: "green" }}>‚úÖ Registered</span>
              ) : (
                <span
                  style={{ color: "red", cursor: "pointer", textDecoration: "underline" }}
                  onClick={handleRegister}
                >
                  ‚ùå Not Registered (Click to Register)
                </span>
              )}
            </p>
            <button onClick={logout}>Logout</button>
          </div>
        )}
      </div>

      <div className="content">{renderContent()}</div>
    </div>
  );
};

export default Dashboard;
